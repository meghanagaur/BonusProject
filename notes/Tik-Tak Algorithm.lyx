#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Tik-Tak Algorithm,following Guvenen (2011)
\end_layout

\begin_layout Standard
Denote the number of parameters to be estimated as 
\begin_inset Formula $J.$
\end_inset

 Let 
\begin_inset Formula $\mathbf{{p}}$
\end_inset

 be a J-dimensional parameter.
\end_layout

\begin_layout Enumerate

\emph on
Initialization
\end_layout

\begin_deeper
\begin_layout Enumerate
Determine parameter bounds for each parameter, outside of which the objective
 function should be set to a high value.
\end_layout

\begin_layout Enumerate
Generate a sequence of Sobol vectors with a sequence length of N.
\end_layout

\begin_layout Enumerate
Evaluate the function value at each of these 
\begin_inset Formula $N$
\end_inset

 Sobol points.
 THIS CAN BE DONE IN PARALLEL.
 Multiprocessing across nodes is fine.
\end_layout

\begin_layout Enumerate
Keep the set 
\begin_inset Formula $N^{*}$
\end_inset

 of points that have the lowest function values, and order them in descending
 order, as 
\begin_inset Formula $s_{1},...,s_{N^{*}}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $N^{*}$
\end_inset

 is the number of restarts in the global stage.
 In one paper, they set 
\begin_inset Formula $N^{*}=0.1\times N.$
\end_inset


\end_layout

\begin_layout Enumerate
Save all of these to a JLD or CSV file.
\end_layout

\begin_layout Enumerate
Set the global iteration number 
\begin_inset Formula $i=1$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Global Stage
\end_layout

\begin_deeper
\begin_layout Enumerate
Draw the 
\begin_inset Formula $i^{th}$
\end_inset

 vector value in the Sobol sequence: 
\begin_inset Formula $s_{i}.$
\end_inset


\end_layout

\begin_layout Enumerate
Open and read from the text file 
\begin_inset Quotes eld
\end_inset

saved_parameters..txt
\begin_inset Quotes erd
\end_inset

 the function values (and corresponding parameter vectors) of the previously
 found local minima.
 Denote the lowest function value found as of ieration 
\begin_inset Formula $i-1$
\end_inset

 as 
\begin_inset Formula $f_{i-1}^{low}$
\end_inset

 and the corresponding parameter vector as 
\begin_inset Formula $p_{i-1}^{low}$
\end_inset

 .
 Denote 
\begin_inset Formula $N_{last}$
\end_inset

 as the total nuber of searches completed by all CPUs.
 
\end_layout

\begin_layout Enumerate
Generate an initial point for the local stage as follows:
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $i<I_{min}$
\end_inset

, then use 
\begin_inset Formula $s_{i}$
\end_inset

 as the starting guess 
\begin_inset Formula $S_{i}.$
\end_inset

 (
\begin_inset Formula $I_{min}$
\end_inset

 is the threshold below which we use fully quasi-random starting points
 in the global stage).
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $i\geq I_{min},$
\end_inset

take the starting guess 
\begin_inset Formula $S_{i}=(1-\theta_{i})s_{I}+\theta_{i}p_{i-1}^{low}$
\end_inset

, where 
\begin_inset Formula $\theta_{i}\in[0,\bar{\bar{\theta}]}$
\end_inset

 and 
\begin_inset Formula $\bar{\theta}<1$
\end_inset

.
 In one paper, they set 
\begin_inset Formula $\theta_{i}=\min[\bar{\theta},(i/N^{*})^{2}]$
\end_inset

, and 
\begin_inset Formula $\bar{\theta}=0.995.$
\end_inset


\end_layout

\begin_layout Itemize
As 
\begin_inset Formula $\theta$
\end_inset

 is increased, local searches are restarted from a narrower part of the
 parameter space that yielded the lowest local minima before.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\emph on
Local Stage
\end_layout

\begin_deeper
\begin_layout Enumerate
Using 
\begin_inset Formula $S_{i}$
\end_inset

 as a starting point, use the Nelder-Mead downhill simplex algorithm to
 search for a local minimum.
 (For the other vertices of the simplex, randomly draw starting points within
 the bounds of the parameter space.)
\end_layout

\begin_layout Enumerate
Stop when either (i) a certain tolerance is acheived (i.e.
 
\begin_inset Formula $10^{-8}$
\end_inset

), (ii) function values do not improve by more than a certain amount, or
 (iii) the maximum iteration number is reached.
 
\end_layout

\begin_layout Enumerate
Open
\begin_inset Quotes eld
\end_inset

saved_parameters.txt
\begin_inset Quotes erd
\end_inset

 and record the local minimum found (function value and parameters).
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Stopping Rule
\end_layout

\begin_deeper
\begin_layout Enumerate
Repeat Steps 2-3 until local searches are completed from starting points
 that utilize each of the 
\begin_inset Formula $N^{*}$
\end_inset

 Sobol points.
 
\end_layout

\begin_layout Enumerate
Return the point with the lowest function value from 
\begin_inset Quotes eld
\end_inset

saved_parameters..txt
\begin_inset Quotes erd
\end_inset

 as the global minimum.
\end_layout

\end_deeper
\begin_layout Section
Extensions
\end_layout

\begin_layout Subsection*
Narrowing Down the Search Area
\end_layout

\begin_layout Standard
As noted, the Nelder-Mead algorithm requires J+1 candidate points as inputs
 (the vertices of the J-dimensional simplex).
 One of these points is given by 
\begin_inset Formula $S_{i}$
\end_inset

.
 The other vertices are drawn randomly.
 After a sufficiently large number of restarts have been compelted, rank
 all of the function values and take the lowest 10 or 20 percent of values.
 Then for each dimension, pick the minimum and maximum parameter values
 within this set of minima (in each dimension).
 To generate vertices, randomly sample points between the minimum and maximum
 in each dimension j.
 This allows the simplex algorithm to search more intensively in a narrower
 area.
\end_layout

\begin_layout Paragraph

\series medium
We can alternatively set the bounds implicitly (see old NYFed code) and
 rescale the parameters so the increments are normaliezed.
 Decide which setup makes more sense.
\end_layout

\begin_layout Subsection*
Parallelizing (Steps 2-3 of) the Algorithm
\end_layout

\begin_layout Itemize
Suppose we have 
\begin_inset Formula $N$
\end_inset

 processes.
 
\end_layout

\begin_layout Itemize
We can distinguish between each process with an integer value 
\begin_inset Formula $n\in\{1,...,N\}.$
\end_inset

 This will be a global variable (this can also be a Slurm environment variable
 if we end up using a SLURM job array instead of Julia's built-in 
\begin_inset Quotes eld
\end_inset

pmap
\begin_inset Quotes erd
\end_inset

 function).
\end_layout

\begin_layout Itemize
Upon starting, each process will load the same Sobol sequence.
\end_layout

\begin_layout Itemize
Let process 
\begin_inset Formula $n$
\end_inset

 choose the 
\begin_inset Formula $n^{th}$
\end_inset

 element of the sequence for its initial point and launch a local search
 from that point.
 After completion, each run will open the same file and record the local
 minimum and parameter value it finds.
 
\end_layout

\begin_layout Itemize
Keep track of the 
\emph on
total 
\emph default
number of local searches completed by all CPUS as 
\begin_inset Formula $N_{last}$
\end_inset

.
 Then we can instead link the increase in 
\begin_inset Formula $\theta_{i}$
\end_inset

 to 
\begin_inset Formula $N_{last}$
\end_inset

.
 We can also select Sobol points using this iteration number, but this could
 be risky since a second process may read the file right after the first
 process reads it because the first process has not yet written to it.
\end_layout

\begin_deeper
\begin_layout Itemize
For now, let the 
\begin_inset Formula $n^{th}$
\end_inset

 process use the 
\begin_inset Formula $N\times k+n^{th}$
\end_inset

 Sobol number for setting it's initial point.
\end_layout

\end_deeper
\begin_layout Section
Questions/Issues
\end_layout

\begin_layout Itemize
Would it be more performant to use a SLURM job array rather than Julia's
 built in pmap functionality for Steps 2-3? The processes are 
\emph on
mostly
\emph default
 independent, except we need to keep track of the 
\emph on
lowest 
\emph default
function value across 
\emph on
all 
\emph default
past iterations (across all processors) to select the intiial point for
 the local search.
 
\end_layout

\begin_layout Itemize
What is the best way to do file I/O for this step,since there will be several
 processors reading and writing to the same txt file? Is there a way to
 lock the file?
\end_layout

\begin_layout Itemize
Is it possible to multithread on each process in Julia on the cluster? If
 so, how do I request this in the Slurm file and in Julia since the number
 of threads utilized in Julia is an envrionment variable that is set when
 starting up Julia (at least for the main task)?
\end_layout

\end_body
\end_document
