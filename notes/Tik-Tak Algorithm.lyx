#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Tik-Tak Algorithm
\end_layout

\begin_layout Standard
Denote the number of parameters to be estimated as 
\begin_inset Formula $J.$
\end_inset

 Let 
\begin_inset Formula $\mathbf{{p}}$
\end_inset

 be a J-dimensional parameter.
\end_layout

\begin_layout Enumerate

\emph on
Initialization
\end_layout

\begin_deeper
\begin_layout Enumerate
Determine parameter bounds for each parameter, outside of which the objective
 function should be set to a high value.
\end_layout

\begin_layout Enumerate
Generate a sequence of Sobol vectors with a sequence length of N.
\end_layout

\begin_layout Enumerate
Evaluate the function value at each of these 
\begin_inset Formula $N$
\end_inset

 Sobol points.
 THIS CAN BE DONE IN PARALLEL.
 (100 CPUs).
 If possible, do shared memory.Otherwise, multiprocessing across nodes is
 fine.
\end_layout

\begin_deeper
\begin_layout Itemize
10000/(24*60*100) = 0.69 days for 
\begin_inset Formula $N=100,000.$
\end_inset

 Supposing 1 minute / function evaluation (no multitheading).
\end_layout

\end_deeper
\begin_layout Enumerate
Keep the set 
\begin_inset Formula $N^{*}$
\end_inset

 of points that have the lowest function values, and order them in descending
 order, as 
\begin_inset Formula $s_{1},...,s_{N^{*}}$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $N^{*}$
\end_inset

 is the number of restarts in the global stage.
 In one paper, they set 
\begin_inset Formula $N^{*}=0.1\times N.$
\end_inset


\end_layout

\begin_layout Enumerate
Save all of these to a JLD or CSV file.
\end_layout

\begin_layout Enumerate
Set the global iteration number i=1.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Global Stage
\end_layout

\begin_deeper
\begin_layout Enumerate
Draw the 
\begin_inset Formula $i^{th}$
\end_inset

 vector value in the Sobol sequence: 
\begin_inset Formula $s_{i}.$
\end_inset


\end_layout

\begin_layout Enumerate
Open and read from the text file 
\begin_inset Quotes eld
\end_inset

saved_parameters..txt
\begin_inset Quotes erd
\end_inset

 the function values (and corresponding parameter vectors) of previously
 found local minima.
 Denote the lowest function value found as of ieration 
\begin_inset Formula $i-1$
\end_inset

as 
\begin_inset Formula $f_{i-1}^{low}$
\end_inset

 and the corresponding parameter vector as 
\begin_inset Formula $p_{i-1}^{low}$
\end_inset

 .
 Denote 
\begin_inset Formula $N_{last}$
\end_inset

 as the total nuber of searches completed by all CPUs.
 
\end_layout

\begin_layout Enumerate
Generate an initial point for the local stage as follows:
\end_layout

\begin_deeper
\begin_layout Itemize
If 
\begin_inset Formula $i<I_{min}$
\end_inset

, then use 
\begin_inset Formula $s_{i}$
\end_inset

 as the starting guess 
\begin_inset Formula $S_{i}.$
\end_inset

 (
\begin_inset Formula $I_{min}$
\end_inset

 is the threshold below which we use fully quasi-random starting points
 in the global stage).
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $i\geq I_{min},$
\end_inset

take the starting guess 
\begin_inset Formula $S_{i}=(1-\theta_{i})s_{I}+\theta_{i}p_{i-1}^{low}$
\end_inset

, where 
\begin_inset Formula $\theta_{i}\in[0,\bar{\bar{\theta}]}$
\end_inset

 and 
\begin_inset Formula $\bar{\theta}<1$
\end_inset

.
 In one paper, they set 
\begin_inset Formula $\theta_{i}=\min[\bar{\theta},(i/N^{*})^{2}]$
\end_inset

, and 
\begin_inset Formula $\bar{\theta}=0.995.$
\end_inset


\end_layout

\begin_layout Itemize
As 
\begin_inset Formula $\theta$
\end_inset

 is increased, local searches are restarted from a narrower part of the
 parameter space that yielded the lowest local minima before.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\emph on
Local Stage
\end_layout

\begin_deeper
\begin_layout Enumerate
Using 
\begin_inset Formula $S_{i}$
\end_inset

 as a starting point, use the Nelder-Mead downhill simplex algorithm to
 search for a local minimum.
 (For the other vertices of the simplex, randomly draw starting points within
 the bounds of the parameter space.)
\end_layout

\begin_layout Enumerate
Stop when either (i) a certain tolerance is acheived (i.e.
 
\begin_inset Formula $10^{-8}$
\end_inset

), (ii) function values do not improve by more than a certain amount, or
 (iii) the maximum iteration number is reached.
 
\end_layout

\begin_layout Enumerate
Open
\begin_inset Quotes eld
\end_inset

saved_parameters.txt
\begin_inset Quotes erd
\end_inset

 and record the local minimum found (function value and parameters).
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Stopping Rule
\end_layout

\begin_deeper
\begin_layout Enumerate
Repeat Steps 2-3 until local searches are completed from starting points
 that utilize each of the 
\begin_inset Formula $N^{*}$
\end_inset

 Sobol points.
 
\end_layout

\begin_layout Enumerate
Return the point with the lowest function value from 
\begin_inset Quotes eld
\end_inset

saved_parameters..txt
\begin_inset Quotes erd
\end_inset

 as the global minimum.
\end_layout

\end_deeper
\begin_layout Section
Extensions
\end_layout

\begin_layout Subsection*
Narrowing Down the Search Area
\end_layout

\begin_layout Standard
As noted, the Nelder-Mead algorithm requires J+1 candidate points as inputs
 (the vertices of the J-dimensional simplex).
 One of these points is given by 
\begin_inset Formula $S_{i}$
\end_inset

.
 The other vertices are drawn randomly.
 After a sufficiently large number of restarts have been compelted, rank
 all of the function values and take the lowest 10 or 20 percent of values.
 Then for each dimension, pick the minimum and maximum parameter values
 within this set of minima (in each dimension).
 To generate vertices, randomly sample points between the minimum and maximum
 in each dimension j.
 This allows the simplex algorithm to search more intensively in a narrower
 area.
\end_layout

\begin_layout Paragraph

\series medium
We can alternatively set the bounds implicitly (see old NYFed code) and
 rescale the parameters so the increments are normaliezed.
 Decide which setup makes more sense.
\end_layout

\begin_layout Subsection*
Parallelizing the Algorithm
\end_layout

\begin_layout Itemize
Suppose we have N processes.
 
\end_layout

\begin_layout Itemize
We can distinguish between each process with an integer value 
\begin_inset Formula $n\in\{1,...,N\}.$
\end_inset

 This will be a global variable (environment variable for SLURM job array).
\end_layout

\begin_layout Itemize
Upon starting, each process will use the same Sobol sequence (saved to network,
 load at start of code).
\end_layout

\begin_layout Itemize
Let process 
\begin_inset Formula $n$
\end_inset

 choose the 
\begin_inset Formula $n^{th}$
\end_inset

 element of the sequence for its initial point, and launches a local search
 from that point.
 After completion, each run will open the same file and record the local
 minimum and parameter value it finds.
\end_layout

\begin_layout Itemize
Keep track of the 
\emph on
total 
\emph default
number of local searches completed by all CPUS as 
\begin_inset Formula $N_{last}$
\end_inset

.
 Then we can link the increase in 
\begin_inset Formula $\theta_{i}$
\end_inset

 to this iteration number.
 Could also select points using this iteration, but I think this might be
 risky since one process may read the file right after the current process,
 but the current process has not yet written to it.
\end_layout

\begin_layout Section
Questions/Issues
\end_layout

\begin_layout Itemize
Ask Princeton IT about the best way to do file I/O in the global stage:
 can we lock the file?
\end_layout

\begin_deeper
\begin_layout Itemize
Ideally, 30 processess,4 CPUs/process? Can use a SLURM job array for the
 separate processes.
\end_layout

\begin_layout Itemize
1000*20*50/(24*60*60*30) = 0.386 days.
 This supposes 1000 starting points, 50 function evals / local minimization,
 20 seconds / function evaluation using 4 threads for each function evaluation,
 and 30 separate processes for global minimization.
\end_layout

\begin_layout Itemize
Can skip multithreading and jack up number of cores (see what is more readily
 available on cluster).
\end_layout

\end_deeper
\end_body
\end_document
